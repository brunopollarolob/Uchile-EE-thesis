
\chapter{Verilog codes}

\definecolor{verilogcommentcolor}{RGB}{104,180,104}
\definecolor{verilogkeywordcolor}{RGB}{49,49,255}
\definecolor{verilogsystemcolor}{RGB}{128,0,255}
\definecolor{verilognumbercolor}{RGB}{255,143,102}
\definecolor{verilogstringcolor}{RGB}{160,160,160}
\definecolor{verilogdefinecolor}{RGB}{128,64,0}
\definecolor{verilogoperatorcolor}{RGB}{0,0,128}

% Verilog style
\lstdefinestyle{prettyverilog}{
   language           = Verilog,
   commentstyle       = \color{verilogcommentcolor},
   alsoletter         = \$'0123456789\`,
   literate           = *{+}{{\verilogColorOperator{+}}}{1}%
                         {-}{{\verilogColorOperator{-}}}{1}%
                         {@}{{\verilogColorOperator{@}}}{1}%
                         {;}{{\verilogColorOperator{;}}}{1}%
                         {*}{{\verilogColorOperator{*}}}{1}%
                         {?}{{\verilogColorOperator{?}}}{1}%
                         {:}{{\verilogColorOperator{:}}}{1}%
                         {<}{{\verilogColorOperator{<}}}{1}%
                         {>}{{\verilogColorOperator{>}}}{1}%
                         {=}{{\verilogColorOperator{=}}}{1}%
                         {!}{{\verilogColorOperator{!}}}{1}%
                         {^}{{\verilogColorOperator{$\land$}}}{1}%
                         {|}{{\verilogColorOperator{|}}}{1}%
                         {=}{{\verilogColorOperator{=}}}{1}%
                         {[}{{\verilogColorOperator{[}}}{1}%
                         {]}{{\verilogColorOperator{]}}}{1}%
                         {(}{{\verilogColorOperator{(}}}{1}%
                         {)}{{\verilogColorOperator{)}}}{1}%
                         {,}{{\verilogColorOperator{,}}}{1}%
                         {.}{{\verilogColorOperator{.}}}{1}%
                         {~}{{\verilogColorOperator{$\sim$}}}{1}%
                         {\%}{{\verilogColorOperator{\%}}}{1}%
                         {\&}{{\verilogColorOperator{\&}}}{1}%
                         {\#}{{\verilogColorOperator{\#}}}{1}%
                         {\ /\ }{{\verilogColorOperator{\ /\ }}}{3}%
                         {\ _}{\ \_}{2}%
                        ,
   morestring         = [s][\color{verilogstringcolor}]{"}{"},%
   identifierstyle    = \color{black},
   vlogdefinestyle    = \color{verilogdefinecolor},
   vlogconstantstyle  = \color{verilognumbercolor},
   vlogsystemstyle    = \color{verilogsystemcolor},
   basicstyle         = \scriptsize\fontencoding{T1}\ttfamily,
   keywordstyle       = \bfseries\color{verilogkeywordcolor},
   numbers            = left,
   numbersep          = 10pt,
   tabsize            = 4,
   escapeinside       = {/*!}{!*/},
   upquote            = true,
   sensitive          = true,
   showstringspaces   = false, %without this there will be a symbol in the places where there is a space
   frame              = single
}


% This is shamelessly stolen and modified from:
% https://github.com/jubobs/sclang-prettifier/blob/master/sclang-prettifier.dtx
\makeatletter

% Language name
\newcommand\language@verilog{Verilog}
\expandafter\lst@NormedDef\expandafter\languageNormedDefd@verilog%
  \expandafter{\language@verilog}
  
% save definition of single quote for testing
\lst@SaveOutputDef{`'}\quotesngl@verilog
\lst@SaveOutputDef{``}\backtick@verilog
\lst@SaveOutputDef{`\$}\dollar@verilog

% Extract first character token in sequence and store in macro 
% firstchar@verilog, per http://tex.stackexchange.com/a/159267/21891
\newcommand\getfirstchar@verilog{}
\newcommand\getfirstchar@@verilog{}
\newcommand\firstchar@verilog{}
\def\getfirstchar@verilog#1{\getfirstchar@@verilog#1\relax}
\def\getfirstchar@@verilog#1#2\relax{\def\firstchar@verilog{#1}}

% Initially empty hook for lst
\newcommand\addedToOutput@verilog{}
\lst@AddToHook{Output}{\addedToOutput@verilog}

% The style used for constants as set in lstdefinestyle
\newcommand\constantstyle@verilog{}
\lst@Key{vlogconstantstyle}\relax%
   {\def\constantstyle@verilog{#1}}

% The style used for defines as set in lstdefinestyle
\newcommand\definestyle@verilog{}
\lst@Key{vlogdefinestyle}\relax%
   {\def\definestyle@verilog{#1}}

% The style used for defines as set in lstdefinestyle
\newcommand\systemstyle@verilog{}
\lst@Key{vlogsystemstyle}\relax%
   {\def\systemstyle@verilog{#1}}

% Counter used to check current character is a digit
\newcount\currentchar@verilog
  
% Processing macro
\newcommand\@ddedToOutput@verilog
{%
   % If we're in \lstpkg{}' processing mode...
   \ifnum\lst@mode=\lst@Pmode%
      % Save the first token in the current identifier to \@getfirstchar
      \expandafter\getfirstchar@verilog\expandafter{\the\lst@token}%
      % Check if the token is a backtick
      \expandafter\ifx\firstchar@verilog\backtick@verilog
         % If so, then this starts a define
         \let\lst@thestyle\definestyle@verilog%
      \else
         % Check if the token is a dollar
         \expandafter\ifx\firstchar@verilog\dollar@verilog
            % If so, then this starts a system command
            \let\lst@thestyle\systemstyle@verilog%
         \else
            % Check if the token starts with a single quote
            \expandafter\ifx\firstchar@verilog\quotesngl@verilog
               % If so, then this starts a constant without length
               \let\lst@thestyle\constantstyle@verilog%
            \else
               \currentchar@verilog=48
               \loop
                  \expandafter\ifnum%
                  \expandafter`\firstchar@verilog=\currentchar@verilog%
                     \let\lst@thestyle\constantstyle@verilog%
                     \let\iterate\relax%
                  \fi
                  \advance\currentchar@verilog by \@ne%
                  \unless\ifnum\currentchar@verilog>57%
               \repeat%
            \fi
         \fi
      \fi
      % ...but override by keyword style if a keyword is detected!
      %\lsthk@DetectKeywords% 
   \fi
}

% Add processing macro only if verilog
\lst@AddToHook{PreInit}{%
  \ifx\lst@language\languageNormedDefd@verilog%
    \let\addedToOutput@verilog\@ddedToOutput@verilog%
  \fi
}

% Colour operators in literate
\newcommand{\verilogColorOperator}[1]
{%
  \ifnum\lst@mode=\lst@Pmode\relax%
   {\bfseries\textcolor{verilogoperatorcolor}{#1}}%
  \else
    #1%
  \fi
}

\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% End Verilog Code Style
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{lstlisting}[style={prettyverilog}, caption={Verilog code for the 4-bit convergent quantizer with gain and dynamic shift.}, label={lst:verilog_quantizer}]
module quantizer (
    input  wire          clk,
    input  wire          ce,
    input  wire signed [30:0] din,   
    input  wire [15:0]   gain,       
    input  wire [5:0]    shift,      
    output reg signed [3:0] dout,
    output reg           clip_flag
);
    // Stage 1: multiplication
    reg signed [47:0] mult_result;
    // Stage 2: shift left
    reg signed [47:0] shifted_stage;
    // Stage 3: rounding variables
    reg signed [47:0] rounded_stage; 
    reg pattern_detect;
    reg signed [47:0] multadd_reg;
    
    // Delays for shifted_stage to align with rounding pipeline
    reg signed [47:0] shifted_stage_d1;  
    reg signed [47:0] shifted_stage_d2;  
    
    // Convergent rounding constants
    wire [43:0] pattern = 44'b00000000000000000000000000000000000000000000;
    wire [47:0] c = 48'b000001111111111111111111111111111111111111111111; 
    wire signed [47:0] multadd;
    
    // Hierarchical OR for fractional part detection (hardware efficient)
    wire frac_nonzero_1 = |shifted_stage_d2[43:33];  // 11 bits
    wire frac_nonzero_2 = |shifted_stage_d2[32:22];  // 11 bits  
    wire frac_nonzero_3 = |shifted_stage_d2[21:11];  // 11 bits
    wire frac_nonzero_4 = |shifted_stage_d2[10:0];   // 11 bits
    wire any_frac_bit = frac_nonzero_1 | frac_nonzero_2 | frac_nonzero_3 | frac_nonzero_4;
    
    // =========================
    // Stage 1: Multiply by gain
    // =========================
    always @(posedge clk) begin
        if (ce)
            mult_result <= din * $signed({1'b0, gain});
        else
            mult_result <= 0;
    end
    
    // =========================
    // Stage 2: Shift LEFT
    // =========================
    always @(posedge clk) begin
        if (ce)
            shifted_stage <= mult_result <<< shift;  // shift left
        else
            shifted_stage <= 0;
    end
    
    // =========================
    // Delay registers for shifted_stage
    // =========================
    always @(posedge clk) begin
        if (ce) begin
            shifted_stage_d1 <= shifted_stage;    
            shifted_stage_d2 <= shifted_stage_d1; 
        end else begin
            shifted_stage_d1 <= 0;
            shifted_stage_d2 <= 0;
        end
    end
    
    // =========================
    // Stage 3: Convergent Rounding Logic
    // =========================
    assign multadd = shifted_stage + c + 1'b1;
    
    always @(posedge clk) begin
        if (ce) begin
            pattern_detect <= (multadd[43:0] == pattern) ? 1'b1 : 1'b0;
            multadd_reg <= multadd;
        end else begin
            pattern_detect <= 1'b0;
            multadd_reg <= 48'b0;
        end
    end
    
    always @(posedge clk) begin
        if (ce) begin
            // Convergent rounding: if pattern detected (midpoint), force LSB to 0
            if (pattern_detect)
                rounded_stage <= {multadd_reg[47:45], 1'b0, multadd_reg[43:0]}; 
            else
                rounded_stage <= multadd_reg; // Normal half up rounding
        end else begin
            rounded_stage <= 48'b0;
        end
    end
    
    // =========================
    // Stage 4: Overflow Detection and Saturation
    // =========================
    always@(posedge clk) begin
        if (ce) begin
            // Use delayed shifted_stage aligned with rounded_stage
            if ((shifted_stage_d2[47:44] == 4'b0111) && any_frac_bit) begin
                // Positive overflow: shifted_stage > 7.0
                dout <= 4'b0111; // Max positive value for 4-bit signed
                clip_flag <= 1'b1;
            end else begin
                // No overflow, assign the rounded value
                dout <= rounded_stage[47:44]; // Take the top 4 bits as output
                clip_flag <= 1'b0;
            end
        end else begin
            dout <= 4'b0;
            clip_flag <= 1'b0;
        end
    end
    
endmodule
\end{lstlisting}

\begin{lstlisting}[style={prettyverilog}, caption={Verilog code for the skid buffer module used in \texttt{sipo.v}.}, label={lst:verilog_skid_buffer}]
module skid_buffer #(
    parameter DIN_WIDTH = 64
) (
    input wire clk,
    input wire rst,

    input wire [DIN_WIDTH-1:0] din,
    input wire din_valid, 
    output wire  din_ready, 

    output wire dout_valid, 
    input wire dout_ready, 
    output wire [DIN_WIDTH-1:0] dout
);

reg [DIN_WIDTH-1:0] din_r=0;

//register valid
reg val=0;
always@(posedge clk)begin
    if(rst)
        val <=0;
    else if((din_valid & din_ready) && (dout_valid & ~dout_ready)) begin
        //there is din valid but dout is stalled
        val <=1;
    end 
    else if(dout_ready)
        val <= 0;
end


//register data
always@(posedge clk)begin
    if(rst)
        din_r <=0;
    else if(din_valid & din_ready)
        din_r <= din;
end

//din ready
assign din_ready = ~val;

//dout side
reg [DIN_WIDTH-1:0] dout_r=0;
reg dout_valid_r=0;


//valid
reg flag =0;
wire flag2 = din_valid | val;
always@(posedge clk)begin
    if(rst)
        dout_valid_r <=0;
    else if((~dout_valid) | dout_ready)begin
        dout_valid_r <= (din_valid | val);
        flag <= 1;
    end
    else
        flag <= 0;
end

//data
always@(posedge clk)begin
    if(rst)
        dout_r <= 0;
    else if((~dout_valid) | dout_ready)begin
        if(val)
            dout_r <= din_r;
        else if(din_valid)
            dout_r <= din;
        else
            dout_r <= 0;
    end
end

assign dout = dout_r;
assign dout_valid = dout_valid_r; 

endmodule
\end{lstlisting}

\begin{lstlisting}[style={prettyverilog}, caption={Verilog code for SIPO converter used in \texttt{hge\_write\_packetizer.v}.}, label={lst:verilog_sipo_converter}]
/* DIN --> time demultiplex --> FIFO --> DOUT */
module sipo #(
    parameter DIN_WIDTH = 64,
    parameter DOUT_WIDTH = 512,
    parameter FIFO_DEPTH = 2048,
    parameter CYCLES = DOUT_WIDTH/DIN_WIDTH,
    parameter TIME_SIZE = $clog2(CYCLES)
) (
    input wire clk,
    input wire rst,
    input wire [DIN_WIDTH-1:0] din,
    input wire din_valid,
    output wire din_ready,
    output wire [DOUT_WIDTH-1:0] dout,
    output wire dout_valid,
    input wire dout_ready,
    output wire fifo_full,
    output wire fifo_almost_full
);

/***
 ***    Skid buffer for input flow control
 ***/
wire [DIN_WIDTH-1:0] sk_dout;
wire sk_valid, sk_ready;

skid_buffer #(
    .DIN_WIDTH(DIN_WIDTH)
) skid_buffer_inst (
    .clk(clk),
    .rst(rst),
    .din(din),
    .din_valid(din_valid), 
    .din_ready(din_ready), 
    .dout_valid(sk_valid), 
    .dout_ready(sk_ready), 
    .dout(sk_dout)
);

/***
 ***    Time demultiplex - serial to parallel accumulation
 ***/
reg [DOUT_WIDTH-1:0] parallel_reg = 0;
reg [$clog2(CYCLES):0] time_demux = 0;

localparam IDLE = 1'b0;
localparam BUSY = 1'b1;
reg state = 0, next_state = 0;

always@(posedge clk) begin
    if(rst)
        state <= IDLE;
    else
        state <= next_state;
end

always@(*) begin
    case(state)
        IDLE: begin
            if(sk_valid & ~full)    next_state = BUSY;
            else                    next_state = IDLE;
        end
        BUSY: begin
            if((time_demux == (CYCLES-1)) & sk_valid & sk_ready)
                next_state = IDLE; 
            else
                next_state = BUSY;
        end
    endcase
end

wire can_accept = ~full & ~almost_full;
assign sk_ready = can_accept;

// Serial to parallel accumulation
always@(posedge clk) begin
    if(rst) begin
        time_demux <= 0;
        parallel_reg <= 0;
    end
    else begin
        case(state)
            IDLE: begin
                if(sk_valid & ~full) begin
                    parallel_reg[DIN_WIDTH*0+:DIN_WIDTH] <= sk_dout;
                    time_demux <= 1;
                end
                else begin
                    time_demux <= 0;
                end
            end
            BUSY: begin
                if(sk_valid & sk_ready) begin
                    parallel_reg[DIN_WIDTH*time_demux+:DIN_WIDTH] <= sk_dout;
                    if(time_demux == (CYCLES-1))
                        time_demux <= 0;
                    else
                        time_demux <= time_demux + 1;
                end
            end
        endcase
    end
end

// Write enable for FIFO
reg wen_fifo = 0;
always@(posedge clk) begin
    if(rst)
        wen_fifo <= 0;
    else
        wen_fifo <= ((state == BUSY) & (time_demux == (CYCLES-1)) & sk_valid & sk_ready);
end

/***
 ***   FIFO
 ***/
reg [$clog2(FIFO_DEPTH):0] waddr = 0, raddr = 0;

// Write pointer
always@(posedge clk) begin
    if(rst)
        waddr <= 0;
    else if(wen_fifo & ~full)
        waddr <= waddr + 1;
end

// Read pointer
always@(posedge clk) begin
    if(rst)
        raddr <= 0;
    else if(dout_ready & ~empty)
        raddr <= raddr + 1;
end

bram_infer #(
    .N_ADDR(FIFO_DEPTH),
    .DATA_WIDTH(DOUT_WIDTH)
) bram_inst (
    .clk(clk),
    .wen(wen_fifo),
    .ren(dout_ready),
    .wadd(waddr[$clog2(FIFO_DEPTH)-1:0]),
    .radd(raddr[$clog2(FIFO_DEPTH)-1:0]),
    .win(parallel_reg),
    .wout(dout)
);

// FIFO control signals
wire empty, full, almost_full;
assign empty = (waddr == raddr);
assign full = ((waddr[$clog2(FIFO_DEPTH)] != raddr[$clog2(FIFO_DEPTH)]) &
               (waddr[$clog2(FIFO_DEPTH)-1:0] == raddr[$clog2(FIFO_DEPTH)-1:0]));

wire [$clog2(FIFO_DEPTH):0] occupancy;
assign occupancy = waddr - raddr;
assign almost_full = (occupancy >= (FIFO_DEPTH - CYCLES));  

assign dout_valid = ~empty;
assign fifo_full = full;
assign fifo_almost_full = almost_full;
endmodule
\end{lstlisting}

\begin{lstlisting}[style={prettyverilog}, caption={Verilog code for the HGE write packetizer used in \texttt{packetizer\_top.v}.}, label={lst:verilog_hge_packetizer}]
module hge_write_packetizer #(
    parameter DIN_WIDTH = 64,
    parameter FIFO_DEPTH = 2048
) (
    input wire clk,
    input wire rst,
    input wire [DIN_WIDTH-1:0] din,
    input wire din_valid,
    output wire din_ready,
    
    // Configuration signals
    input wire [31:0] pkt_len,
    input wire [31:0] idle_cycles,
    
    // To the 100GbE 
    output wire [511:0] tx_data,
    output wire tx_valid,
    output wire tx_eof,
    output wire fifo_full,
    output wire fifo_empty
);

wire [511:0] tge_data;
wire tge_data_valid;
wire sipo_din_ready;

// ==========================================
// STATE MACHINE: IDLE -> HEADER -> DATA
// ==========================================
localparam IDLE   = 2'b00;
localparam HEADER = 2'b01;
localparam DATA   = 2'b10;

reg [1:0] state = IDLE;
reg [1:0] next_state;
reg [31:0] counter = 0;
reg [31:0] idle_counter = 0;
reg [63:0] packet_counter = 0;

reg [511:0] dout = 0;
reg dout_valid = 0;
reg header_valid = 0;
reg eof = 0;
reg sipo_ready_r = 0;

wire valid_transfer_data = tge_data_valid & sipo_ready_r;

// Build simple header: packet counter in LSB [63:0], rest zeros
wire [511:0] header_word = {448'h0, packet_counter};

// State machine (combinational)
always@(*) begin
    case(state)
        IDLE: begin
            if(idle_counter == (idle_cycles - 1))
                next_state = HEADER;
            else
                next_state = IDLE;
        end
        
        HEADER: begin
            next_state = DATA;
        end
        
        DATA: begin
            if((counter == pkt_len) && valid_transfer_data)
                next_state = IDLE;
            else
                next_state = DATA;
        end
        
        default: next_state = IDLE;
    endcase
end

// State register
always@(posedge clk) begin
    if(rst)
        state <= IDLE;
    else
        state <= next_state;
end

// Counter logic
always@(posedge clk) begin
    if(rst) begin
        counter <= 0;
        idle_counter <= 0;
    end
    else begin
        case(state)
            IDLE: begin
                counter <= 0;
                if(idle_counter == (idle_cycles - 1))
                    idle_counter <= 0;
                else
                    idle_counter <= idle_counter + 1;
            end
            
            HEADER: begin
                counter <= 0;
                idle_counter <= 0;
            end
            
            DATA: begin
                if(valid_transfer_data) begin
                    if(counter == pkt_len)
                        counter <= 0;
                    else
                        counter <= counter + 1;
                end
            end
        endcase
    end
end

// Packet counter
always@(posedge clk) begin
    if(rst)
        packet_counter <= 0;
    else if((state == DATA) && (counter == pkt_len) && valid_transfer_data)
        packet_counter <= packet_counter + 1;
end

// ==========================================
// OUTPUT MUX: BYPASS HEADER, PASS DATA
// ==========================================

// Data register (only for header)
reg [511:0] header_reg = 0;

always@(posedge clk) begin
    if(rst)
        header_reg <= 0;
    else if(next_state == HEADER)
        header_reg <= header_word;
    else if (state == DATA)
        dout <= tge_data;
end

// Output valid
always@(posedge clk) begin
    if(rst) begin
        dout_valid <= 0;
    end
    else begin
        case(state)
            IDLE: begin
                dout_valid <= 0;
            end
            
            HEADER: begin
                dout_valid <= 0;
            end
            
            DATA: begin
                dout_valid <= valid_transfer_data;
            end
            
            default: begin
                dout_valid <= 0;
            end
        endcase
    end
end

// EOF signal
always@(posedge clk) begin
    if(rst) begin
        eof <= 0;
    end
    else begin
        if((state == DATA) && (counter == pkt_len) && valid_transfer_data)
            eof <= 1;
        else
            eof <= 0;
    end
end

// Header valid
always@(posedge clk) begin
    if(rst)
        header_valid <= 0;
    else
        header_valid <= (next_state == HEADER);  
end

// SIPO ready control
always@(posedge clk) begin
    if(rst)
        sipo_ready_r <= 0;
    else
        sipo_ready_r <= (state == DATA);
end

sipo #(
    .DIN_WIDTH(DIN_WIDTH),
    .DOUT_WIDTH(512),
    .FIFO_DEPTH(FIFO_DEPTH)
) sipo_inst (
    .clk(clk),
    .rst(rst),
    .din(din),
    .din_valid(din_valid),
    .din_ready(sipo_din_ready),
    .dout(tge_data),
    .dout_valid(tge_data_valid),
    .dout_ready(sipo_ready_r),
    .fifo_full(fifo_full)
);

assign din_ready = sipo_din_ready;

// ==========================================
// OUTPUT MUX: Select header or SIPO data
// ==========================================
assign tx_data = (state == HEADER) ? header_reg : dout;
assign tx_valid = (state == HEADER) ? header_valid : dout_valid;
assign tx_eof = eof;
assign fifo_empty = ~tge_data_valid;

endmodule
\end{lstlisting}

\begin{lstlisting}[style={prettyverilog}, caption={Verilog code for the top-level packetizer module used in the HGE write path.}, label={lst:verilog_packetizer_top}]
`include "/home/bruno/f-engine/simulink_models/includes.v"
module packetizer_top 
 (
    input wire clk,
    input wire ce,
    input wire rst,
    input wire [63:0] din,
    input wire din_valid,
    
    //configuration signals
    input wire [31:0] pkt_len,
   // input wire [31:0] sleep_cycles,
    
    //to the HGE 
    output wire [511:0] tx_data,
    output wire tx_valid,

    output wire tx_eof,

    output wire fifo_full,
    output wire fifo_empty           
);


hge_write_packetizer #(
    .DIN_WIDTH(64),
    .FIFO_DEPTH(2048)
) hge_write_packetizer_inst (
    .clk(clk),
    .rst(rst),
    .din(din),
    .din_valid(din_valid),
    .pkt_len(pkt_len),
   // .sleep_cycles(sleep_cycles),
    .tx_data(tx_data),
    .tx_valid(tx_valid),
    .tx_eof(tx_eof),
    .fifo_full(fifo_full),
    .fifo_empty(fifo_empty) 
);

endmodule
\end{lstlisting}